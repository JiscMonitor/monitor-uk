<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>service.lantern API documentation</title>
    <meta name="description" content="Module which handles all the Lantern integration needs" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#service.lantern.LanternApi">LanternApi</a></span>
        
          
  <ul>
    <li class="mono"><a href="#service.lantern.LanternApi.check_jobs">check_jobs</a></li>
    <li class="mono"><a href="#service.lantern.LanternApi.make_new_jobs">make_new_jobs</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">service.lantern</span> module</h1>
  <p>Module which handles all the Lantern integration needs</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-service.lantern', this);">Show source &equiv;</a></p>
  <div id="source-service.lantern" class="source">
    <pre><code>"""
Module which handles all the Lantern integration needs
"""

from octopus.core import app
from octopus.modules.lantern import client
from octopus.lib import dates, dataobj

from service.models import MonitorUKAccount, PublicAPC, LanternJob, Enhancement


class LanternApi(object):
    """
    Static class which provides methods for integrating with Lantern
    """

    @classmethod
    def make_new_jobs(cls):
        """
        Send new requests to lantern, and record the jobs that are created.

        This method looks for accounts who have Lantern credentials, looks for PublicAPC records belonging to those
        accounts which could benefit from lookup in Lantern,

        :return:
        """
        dao = PublicAPC()

        gen = MonitorUKAccount.list_lantern_enabled(keepalive="1h")
        for acc in gen:
            gen2 = dao.list_by_owner(acc.id)
            identifiers = []
            for apc in gen2:
                if LanternApi._needs_lantern_data(apc):
                    idents = LanternApi._get_identifiers(apc)
                    if idents is not None:
                        identifiers.append(idents)
                    apc.lantern_lookup = dates.now()
                    apc.save()

            # if there are no identifiers, no need to do any more
            if len(identifiers) == 0:
                continue

            # now check the user's quota
            lc = client.Lantern(api_key=acc.lantern_api_key)
            quota = lc.get_quota(acc.lantern_email)
            available = quota.get("data", {}).get("available", 0)
            if available == 0:
                continue

            if len(identifiers) > available:
                identifiers = identifiers[:available]

            batches = LanternApi._batch(identifiers)
            for batch in batches:
                resp = lc.create_job(acc.lantern_email, "monitor-uk", batch)
                if resp.get("status") == "success":
                    job_id = resp.get("data", {}).get("job")
                    lj = LanternJob()
                    lj.job_id = job_id
                    lj.account = acc.id
                    lj.status = "active"
                    lj.save()

    @classmethod
    def check_jobs(cls):
        """
        Check any existing Lantern jobs for progress, and process any that have completed

        :return:
        """
        dao = LanternJob()

        delay = app.config.get("JOB_LOOKUP_DELAY_LANTERN", 3600)
        cutoff = dates.before_now(delay)
        gen = dao.list_active(cutoff, keepalive="30m")

        for job in gen:
            acc = MonitorUKAccount.pull(job.account)
            lc = client.Lantern(api_key=acc.lantern_api_key)
            prog = lc.get_progress(job.job_id)
            if prog.get("status") == "success":
                pc = prog.get("data",  {}).get("progress", 0)
                if pc != 100:
                    # this will update the last_updated date, which means we won't look at it again for a while
                    job.save()
                    continue

                # if we get here, the job is complete so we need to retrieve it
                results = lc.get_results(job.job_id)
                if results.get("status") == "success":
                    for res in results.get("data", []):
                        enhancement = LanternApi._xwalk(res)
                        enhancement.save()

                # set the job as complete
                job.status = "complete"
                job.save()

    @classmethod
    def _needs_lantern_data(cls, apc):
        """
        Check to see if the PublicAPC record could benefit from Lantern lookup

        :param apc:
        :return:
        """
        refresh = app.config.get("DATA_REFRESH_LANTERN", 15552000)
        cutoff = dates.before_now(refresh)
        ds = apc.lantern_lookup_datestamp
        if ds is not None and ds > cutoff:
            return False

        fields = app.config.get("MISSING_FIELD_TRIGGERS_LANTERN", [])
        for field in fields:
            vals = apc.objectpath(field)
            if vals is None:
                return True
            hasVal = False
            for v in vals:
                if v:      # not empty string, None or False
                    hasVal = True
            if not hasVal:
                return True
        return False

    @classmethod
    def _get_identifiers(cls, apc):
        """
        Get the identifiers from the PublicAPC

        :param apc:
        :return:
        """
        ident = {}
        if apc.doi:
            ident["DOI"] = apc.doi
        if apc.pmcid:
            ident["PMCID"] = apc.pmcid
        if apc.pmid:
            ident["PMID"] = apc.pmid
        if len(ident.keys()) > 0:
            return ident
        return None

    @classmethod
    def _batch(cls, identifiers):
        """
        Batch the identifiers up for submission

        :param identifiers:
        :return:
        """
        size = app.config.get("BATCH_SIZE_LANTERN", 1000)
        batches = []
        lower = 0
        upper = size
        while upper < len(identifiers):
            batches.append(identifiers[lower:upper])
            lower = upper
            upper = upper + size
        batches.append(identifiers[lower:upper])
        return batches

    @classmethod
    def _xwalk(cls, result):
        """
        Crosswalk the Lantern result to an Enhancement object

        :param result:
        :return:
        """
        journal_record = result.get("journal", {})

        # publication date
        publication_date = None
        if journal_record is not None:
            publication_date = journal_record.get("dateOfPublication")
            try:
                dates.parse(publication_date)
            except:
                publication_date = None

        # Version
        is_aam = result.get("is_aam", False)
        version = None
        if is_aam is not None and is_aam is not False:
            version = "AAM"

        # authors
        authors = result.get("author", [])
        eauthors = []
        if authors is not None:
            for author in authors:
                ea = {}
                if author.get("fullName") is not None:
                    ea["name"] = author.get("fullName")
                if author.get("affiliation") is not None:
                    ea["affiliation"] = [{"name" : author.get("affiliation")}]
                if len(ea.keys()) > 0:
                    eauthors.append(ea)

        # publisher
        publisher = result.get("publisher")

        # DOI
        doi = result.get("doi")

        # pmcid
        pmcid = result.get("pmcid")

        # pmid
        pmid = result.get("pmid")

        journal = None
        issn = None
        essn = None
        oa_type = "unknown"

        if journal_record is not None:
            # journal title
            journal = journal_record.get("title")

            # issn
            issn = journal_record.get("issn")

            # essn
            essn = journal_record.get("eissn")

            # oa type
            in_doaj = journal_record.get("in_doaj")
            if in_doaj is not None:
                if in_doaj is True:
                    oa_type = "oa"
                else:
                    oa_type = "hybrid"

        # self_archiving policies
        archiving = result.get("archiving")
        archive_preprint = False
        archive_postprint = False
        archive_pdf = False
        if archiving is not None:
            archive_preprint = archiving.get("preprint", False)
            archive_postprint = archiving.get("postprint", False)
            archive_pdf = archiving.get("pdf", False)

        # embargo policies
        embargo = result.get("embargo")
        embargo_preprint = False
        embargo_postprint = False
        embargo_pdf = False
        if embargo is not None:
            embargo_preprint = result.get("embargo", {}).get("preprint", False)
            if not isinstance(embargo_preprint, bool):
                try:
                    embargo_preprint = int(embargo_preprint)
                except: pass
            embargo_postprint = result.get("embargo", {}).get("postprint", False)
            if not isinstance(embargo_postprint, bool):
                try:
                    embargo_postprint = int(embargo_postprint)
                except: pass
            embargo_pdf = result.get("embargo", {}).get("pdf", False)
            if not isinstance(embargo_pdf, bool):
                try:
                    embargo_pdf = int(embargo_pdf)
                except: pass

        # grant funding
        projects = []
        grants = result.get("grants", [])
        if grants is not None:
            for g in grants:
                project = {}
                grant_number = g.get("grantId")
                if grant_number is not None:
                    project["grant_number"] = grant_number
                agency = g.get("agency")
                if agency is not None:
                    project["funder_name"] = agency
                if len(project.keys()) > 0:
                    projects.append(project)

        # licence
        licence_type = None
        free_to_read = False
        licence = result.get("licence")
        if licence != "non-standard-licence":
            if licence == "free-to-read":
                free_to_read = True
            elif licence != "unknown":
                licence_type = licence

        # provenance
        prov = result.get("provenance", [])
        if prov is not None:
            prov = "Record enhanced via Lantern (not all data necessarily used), which provided provenance information: " + "; ".join(prov)

        # repository
        repository = result.get("repositories", [])
        rrecords = []
        if repository is not None:
            for r in repository:
                obj = {}
                if isinstance(r, basestring):
                    obj["repo_name"] = r
                    obj["metadata"] = "True"
                    obj["fulltext"] = "Unknown"
                    obj["machine_readable_fulltext"] = "Unknown"
                elif isinstance(r, dict):
                    obj["metadata"] = "True"
                    obj["fulltext"] = "Unknown"
                    obj["machine_readable_fulltext"] = "Unknown"
                    if "name" in r:
                        obj["repo_name"] = r["name"]
                    if "url" in r:
                        obj["repo_url"] = r["url"]
                    if "fulltexts" in r and len(r["fulltexts"]) > 0:
                        obj["record_url"] = " | ".join(r["fulltexts"])

                if len(obj.keys()) > 0:
                    rrecords.append(obj)

        # article title
        title = result.get("title")

        # assign the values to the object
        do = dataobj.DataObj()

        if publication_date is not None:
            do._set_single("rioxxterms:publication_date", publication_date)
        if version is not None:
            do._set_single("rioxxterms:version", version)
        if len(eauthors) > 0:
            do._set_single("rioxxterms:author", eauthors)
        if publisher is not None:
            do._set_single("dcterms:publisher.name", publisher)
        if doi is not None:
            do._add_to_list("dc:identifier", {"type" : "doi", "id" : doi})
        if pmcid is not None:
            do._add_to_list("dc:identifier", {"type" : "pmcid", "id" : pmcid})
        if pmid is not None:
            do._add_to_list("dc:identifier", {"type" : "pmid", "id" : pmid})
        if journal is not None:
            do._set_single("dc:source.name", journal)
        if issn is not None:
            do._add_to_list("dc:source.identifier", {"type" : "issn", "id" : issn})
        if issn is not None:
            do._add_to_list("dc:source.identifier", {"type" : "e-issn", "id" : essn})
        if oa_type is not None:
            do._set_single("dc:source.oa_type", oa_type)
        if isinstance(archive_preprint, basestring):
            do._set_single("dc:source.self_archiving.preprint.policy", archive_preprint)
        if isinstance(archive_postprint, basestring):
            do._set_single("dc:source.self_archiving.postprint.policy", archive_postprint)
        if isinstance(archive_pdf, basestring):
            do._set_single("dc:source.self_archiving.publisher.policy", archive_pdf)
        if isinstance(embargo_preprint, int) and not isinstance(embargo_preprint, bool):
            do._set_single("dc:source.self_archiving.preprint.embargo", embargo_preprint)
        if isinstance(embargo_postprint, int) and not isinstance(embargo_postprint, bool):
            do._set_single("dc:source.self_archiving.postprint.embargo", embargo_postprint)
        if isinstance(embargo_pdf, int) and not isinstance(embargo_pdf, bool):
            do._set_single("dc:source.self_archiving.publisher.embargo", embargo_pdf)
        if len(projects) > 0:
            do._set_single("rioxxterms:project", projects)
        if licence_type is not None:
            do._add_to_list("ali:license_ref", {"type" : licence_type})
        if free_to_read is True:
            do._set_single("ali:free_to_read.free_to_read", free_to_read)
        do._add_to_list("jm:provenance", prov)
        if len(rrecords) > 0:
            do._set_single("jm:repository", rrecords)
        if title is not None:
            do._set_single("dc:title", title)

        # build and return an Enhancement object around the data
        e = Enhancement({"record" : do.data})
        return e

</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="service.lantern.LanternApi" class="name">class <span class="ident">LanternApi</span></p>
      
  
    <div class="desc"><p>Static class which provides methods for integrating with Lantern</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-service.lantern.LanternApi', this);">Show source &equiv;</a></p>
  <div id="source-service.lantern.LanternApi" class="source">
    <pre><code>class LanternApi(object):
    """
    Static class which provides methods for integrating with Lantern
    """

    @classmethod
    def make_new_jobs(cls):
        """
        Send new requests to lantern, and record the jobs that are created.

        This method looks for accounts who have Lantern credentials, looks for PublicAPC records belonging to those
        accounts which could benefit from lookup in Lantern,

        :return:
        """
        dao = PublicAPC()

        gen = MonitorUKAccount.list_lantern_enabled(keepalive="1h")
        for acc in gen:
            gen2 = dao.list_by_owner(acc.id)
            identifiers = []
            for apc in gen2:
                if LanternApi._needs_lantern_data(apc):
                    idents = LanternApi._get_identifiers(apc)
                    if idents is not None:
                        identifiers.append(idents)
                    apc.lantern_lookup = dates.now()
                    apc.save()

            # if there are no identifiers, no need to do any more
            if len(identifiers) == 0:
                continue

            # now check the user's quota
            lc = client.Lantern(api_key=acc.lantern_api_key)
            quota = lc.get_quota(acc.lantern_email)
            available = quota.get("data", {}).get("available", 0)
            if available == 0:
                continue

            if len(identifiers) > available:
                identifiers = identifiers[:available]

            batches = LanternApi._batch(identifiers)
            for batch in batches:
                resp = lc.create_job(acc.lantern_email, "monitor-uk", batch)
                if resp.get("status") == "success":
                    job_id = resp.get("data", {}).get("job")
                    lj = LanternJob()
                    lj.job_id = job_id
                    lj.account = acc.id
                    lj.status = "active"
                    lj.save()

    @classmethod
    def check_jobs(cls):
        """
        Check any existing Lantern jobs for progress, and process any that have completed

        :return:
        """
        dao = LanternJob()

        delay = app.config.get("JOB_LOOKUP_DELAY_LANTERN", 3600)
        cutoff = dates.before_now(delay)
        gen = dao.list_active(cutoff, keepalive="30m")

        for job in gen:
            acc = MonitorUKAccount.pull(job.account)
            lc = client.Lantern(api_key=acc.lantern_api_key)
            prog = lc.get_progress(job.job_id)
            if prog.get("status") == "success":
                pc = prog.get("data",  {}).get("progress", 0)
                if pc != 100:
                    # this will update the last_updated date, which means we won't look at it again for a while
                    job.save()
                    continue

                # if we get here, the job is complete so we need to retrieve it
                results = lc.get_results(job.job_id)
                if results.get("status") == "success":
                    for res in results.get("data", []):
                        enhancement = LanternApi._xwalk(res)
                        enhancement.save()

                # set the job as complete
                job.status = "complete"
                job.save()

    @classmethod
    def _needs_lantern_data(cls, apc):
        """
        Check to see if the PublicAPC record could benefit from Lantern lookup

        :param apc:
        :return:
        """
        refresh = app.config.get("DATA_REFRESH_LANTERN", 15552000)
        cutoff = dates.before_now(refresh)
        ds = apc.lantern_lookup_datestamp
        if ds is not None and ds > cutoff:
            return False

        fields = app.config.get("MISSING_FIELD_TRIGGERS_LANTERN", [])
        for field in fields:
            vals = apc.objectpath(field)
            if vals is None:
                return True
            hasVal = False
            for v in vals:
                if v:      # not empty string, None or False
                    hasVal = True
            if not hasVal:
                return True
        return False

    @classmethod
    def _get_identifiers(cls, apc):
        """
        Get the identifiers from the PublicAPC

        :param apc:
        :return:
        """
        ident = {}
        if apc.doi:
            ident["DOI"] = apc.doi
        if apc.pmcid:
            ident["PMCID"] = apc.pmcid
        if apc.pmid:
            ident["PMID"] = apc.pmid
        if len(ident.keys()) > 0:
            return ident
        return None

    @classmethod
    def _batch(cls, identifiers):
        """
        Batch the identifiers up for submission

        :param identifiers:
        :return:
        """
        size = app.config.get("BATCH_SIZE_LANTERN", 1000)
        batches = []
        lower = 0
        upper = size
        while upper < len(identifiers):
            batches.append(identifiers[lower:upper])
            lower = upper
            upper = upper + size
        batches.append(identifiers[lower:upper])
        return batches

    @classmethod
    def _xwalk(cls, result):
        """
        Crosswalk the Lantern result to an Enhancement object

        :param result:
        :return:
        """
        journal_record = result.get("journal", {})

        # publication date
        publication_date = None
        if journal_record is not None:
            publication_date = journal_record.get("dateOfPublication")
            try:
                dates.parse(publication_date)
            except:
                publication_date = None

        # Version
        is_aam = result.get("is_aam", False)
        version = None
        if is_aam is not None and is_aam is not False:
            version = "AAM"

        # authors
        authors = result.get("author", [])
        eauthors = []
        if authors is not None:
            for author in authors:
                ea = {}
                if author.get("fullName") is not None:
                    ea["name"] = author.get("fullName")
                if author.get("affiliation") is not None:
                    ea["affiliation"] = [{"name" : author.get("affiliation")}]
                if len(ea.keys()) > 0:
                    eauthors.append(ea)

        # publisher
        publisher = result.get("publisher")

        # DOI
        doi = result.get("doi")

        # pmcid
        pmcid = result.get("pmcid")

        # pmid
        pmid = result.get("pmid")

        journal = None
        issn = None
        essn = None
        oa_type = "unknown"

        if journal_record is not None:
            # journal title
            journal = journal_record.get("title")

            # issn
            issn = journal_record.get("issn")

            # essn
            essn = journal_record.get("eissn")

            # oa type
            in_doaj = journal_record.get("in_doaj")
            if in_doaj is not None:
                if in_doaj is True:
                    oa_type = "oa"
                else:
                    oa_type = "hybrid"

        # self_archiving policies
        archiving = result.get("archiving")
        archive_preprint = False
        archive_postprint = False
        archive_pdf = False
        if archiving is not None:
            archive_preprint = archiving.get("preprint", False)
            archive_postprint = archiving.get("postprint", False)
            archive_pdf = archiving.get("pdf", False)

        # embargo policies
        embargo = result.get("embargo")
        embargo_preprint = False
        embargo_postprint = False
        embargo_pdf = False
        if embargo is not None:
            embargo_preprint = result.get("embargo", {}).get("preprint", False)
            if not isinstance(embargo_preprint, bool):
                try:
                    embargo_preprint = int(embargo_preprint)
                except: pass
            embargo_postprint = result.get("embargo", {}).get("postprint", False)
            if not isinstance(embargo_postprint, bool):
                try:
                    embargo_postprint = int(embargo_postprint)
                except: pass
            embargo_pdf = result.get("embargo", {}).get("pdf", False)
            if not isinstance(embargo_pdf, bool):
                try:
                    embargo_pdf = int(embargo_pdf)
                except: pass

        # grant funding
        projects = []
        grants = result.get("grants", [])
        if grants is not None:
            for g in grants:
                project = {}
                grant_number = g.get("grantId")
                if grant_number is not None:
                    project["grant_number"] = grant_number
                agency = g.get("agency")
                if agency is not None:
                    project["funder_name"] = agency
                if len(project.keys()) > 0:
                    projects.append(project)

        # licence
        licence_type = None
        free_to_read = False
        licence = result.get("licence")
        if licence != "non-standard-licence":
            if licence == "free-to-read":
                free_to_read = True
            elif licence != "unknown":
                licence_type = licence

        # provenance
        prov = result.get("provenance", [])
        if prov is not None:
            prov = "Record enhanced via Lantern (not all data necessarily used), which provided provenance information: " + "; ".join(prov)

        # repository
        repository = result.get("repositories", [])
        rrecords = []
        if repository is not None:
            for r in repository:
                obj = {}
                if isinstance(r, basestring):
                    obj["repo_name"] = r
                    obj["metadata"] = "True"
                    obj["fulltext"] = "Unknown"
                    obj["machine_readable_fulltext"] = "Unknown"
                elif isinstance(r, dict):
                    obj["metadata"] = "True"
                    obj["fulltext"] = "Unknown"
                    obj["machine_readable_fulltext"] = "Unknown"
                    if "name" in r:
                        obj["repo_name"] = r["name"]
                    if "url" in r:
                        obj["repo_url"] = r["url"]
                    if "fulltexts" in r and len(r["fulltexts"]) > 0:
                        obj["record_url"] = " | ".join(r["fulltexts"])

                if len(obj.keys()) > 0:
                    rrecords.append(obj)

        # article title
        title = result.get("title")

        # assign the values to the object
        do = dataobj.DataObj()

        if publication_date is not None:
            do._set_single("rioxxterms:publication_date", publication_date)
        if version is not None:
            do._set_single("rioxxterms:version", version)
        if len(eauthors) > 0:
            do._set_single("rioxxterms:author", eauthors)
        if publisher is not None:
            do._set_single("dcterms:publisher.name", publisher)
        if doi is not None:
            do._add_to_list("dc:identifier", {"type" : "doi", "id" : doi})
        if pmcid is not None:
            do._add_to_list("dc:identifier", {"type" : "pmcid", "id" : pmcid})
        if pmid is not None:
            do._add_to_list("dc:identifier", {"type" : "pmid", "id" : pmid})
        if journal is not None:
            do._set_single("dc:source.name", journal)
        if issn is not None:
            do._add_to_list("dc:source.identifier", {"type" : "issn", "id" : issn})
        if issn is not None:
            do._add_to_list("dc:source.identifier", {"type" : "e-issn", "id" : essn})
        if oa_type is not None:
            do._set_single("dc:source.oa_type", oa_type)
        if isinstance(archive_preprint, basestring):
            do._set_single("dc:source.self_archiving.preprint.policy", archive_preprint)
        if isinstance(archive_postprint, basestring):
            do._set_single("dc:source.self_archiving.postprint.policy", archive_postprint)
        if isinstance(archive_pdf, basestring):
            do._set_single("dc:source.self_archiving.publisher.policy", archive_pdf)
        if isinstance(embargo_preprint, int) and not isinstance(embargo_preprint, bool):
            do._set_single("dc:source.self_archiving.preprint.embargo", embargo_preprint)
        if isinstance(embargo_postprint, int) and not isinstance(embargo_postprint, bool):
            do._set_single("dc:source.self_archiving.postprint.embargo", embargo_postprint)
        if isinstance(embargo_pdf, int) and not isinstance(embargo_pdf, bool):
            do._set_single("dc:source.self_archiving.publisher.embargo", embargo_pdf)
        if len(projects) > 0:
            do._set_single("rioxxterms:project", projects)
        if licence_type is not None:
            do._add_to_list("ali:license_ref", {"type" : licence_type})
        if free_to_read is True:
            do._set_single("ali:free_to_read.free_to_read", free_to_read)
        do._add_to_list("jm:provenance", prov)
        if len(rrecords) > 0:
            do._set_single("jm:repository", rrecords)
        if title is not None:
            do._set_single("dc:title", title)

        # build and return an Enhancement object around the data
        e = Enhancement({"record" : do.data})
        return e
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#service.lantern.LanternApi">LanternApi</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="service.lantern.LanternApi.check_jobs">
    <p>def <span class="ident">check_jobs</span>(</p><p>cls)</p>
    </div>
    

    
  
    <div class="desc"><p>Check any existing Lantern jobs for progress, and process any that have completed</p>
<p>:return:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-service.lantern.LanternApi.check_jobs', this);">Show source &equiv;</a></p>
  <div id="source-service.lantern.LanternApi.check_jobs" class="source">
    <pre><code>@classmethod
def check_jobs(cls):
    """
    Check any existing Lantern jobs for progress, and process any that have completed
    :return:
    """
    dao = LanternJob()
    delay = app.config.get("JOB_LOOKUP_DELAY_LANTERN", 3600)
    cutoff = dates.before_now(delay)
    gen = dao.list_active(cutoff, keepalive="30m")
    for job in gen:
        acc = MonitorUKAccount.pull(job.account)
        lc = client.Lantern(api_key=acc.lantern_api_key)
        prog = lc.get_progress(job.job_id)
        if prog.get("status") == "success":
            pc = prog.get("data",  {}).get("progress", 0)
            if pc != 100:
                # this will update the last_updated date, which means we won't look at it again for a while
                job.save()
                continue
            # if we get here, the job is complete so we need to retrieve it
            results = lc.get_results(job.job_id)
            if results.get("status") == "success":
                for res in results.get("data", []):
                    enhancement = LanternApi._xwalk(res)
                    enhancement.save()
            # set the job as complete
            job.status = "complete"
            job.save()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="service.lantern.LanternApi.make_new_jobs">
    <p>def <span class="ident">make_new_jobs</span>(</p><p>cls)</p>
    </div>
    

    
  
    <div class="desc"><p>Send new requests to lantern, and record the jobs that are created.</p>
<p>This method looks for accounts who have Lantern credentials, looks for PublicAPC records belonging to those
accounts which could benefit from lookup in Lantern,</p>
<p>:return:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-service.lantern.LanternApi.make_new_jobs', this);">Show source &equiv;</a></p>
  <div id="source-service.lantern.LanternApi.make_new_jobs" class="source">
    <pre><code>@classmethod
def make_new_jobs(cls):
    """
    Send new requests to lantern, and record the jobs that are created.
    This method looks for accounts who have Lantern credentials, looks for PublicAPC records belonging to those
    accounts which could benefit from lookup in Lantern,
    :return:
    """
    dao = PublicAPC()
    gen = MonitorUKAccount.list_lantern_enabled(keepalive="1h")
    for acc in gen:
        gen2 = dao.list_by_owner(acc.id)
        identifiers = []
        for apc in gen2:
            if LanternApi._needs_lantern_data(apc):
                idents = LanternApi._get_identifiers(apc)
                if idents is not None:
                    identifiers.append(idents)
                apc.lantern_lookup = dates.now()
                apc.save()
        # if there are no identifiers, no need to do any more
        if len(identifiers) == 0:
            continue
        # now check the user's quota
        lc = client.Lantern(api_key=acc.lantern_api_key)
        quota = lc.get_quota(acc.lantern_email)
        available = quota.get("data", {}).get("available", 0)
        if available == 0:
            continue
        if len(identifiers) > available:
            identifiers = identifiers[:available]
        batches = LanternApi._batch(identifiers)
        for batch in batches:
            resp = lc.create_job(acc.lantern_email, "monitor-uk", batch)
            if resp.get("status") == "success":
                job_id = resp.get("data", {}).get("job")
                lj = LanternJob()
                lj.job_id = job_id
                lj.account = acc.id
                lj.status = "active"
                lj.save()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
